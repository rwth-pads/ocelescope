/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * OCEAn
 * OpenAPI spec version: 0.9.12
 */
import {
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  E2oParams,
  EntityTimeInfo,
  EventAttributes200,
  EventAttributesParams,
  EventCounts200,
  EventCountsParams,
  HTTPValidationError,
  O2oParams,
  ObjectAttributes200,
  ObjectAttributesParams,
  ObjectCount200,
  ObjectCountParams,
  RelationCountSummary,
  TimeInfoParams
} from '../../fastapi-schemas';

import { customFetch } from '../../fetcher';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary Get Object Attributes
 */
export const getObjectAttributesUrl = (params?: ObjectAttributesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:8000/info/objects/attributes?${stringifiedParams}` : `http://localhost:8000/info/objects/attributes`
}

export const objectAttributes = async (params?: ObjectAttributesParams, options?: RequestInit): Promise<ObjectAttributes200> => {
  
  return customFetch<ObjectAttributes200>(getObjectAttributesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getObjectAttributesQueryKey = (params?: ObjectAttributesParams,) => {
    return [`http://localhost:8000/info/objects/attributes`, ...(params ? [params]: [])] as const;
    }

    
export const getObjectAttributesQueryOptions = <TData = Awaited<ReturnType<typeof objectAttributes>>, TError = HTTPValidationError>(params?: ObjectAttributesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof objectAttributes>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getObjectAttributesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof objectAttributes>>> = ({ signal }) => objectAttributes(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 300000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof objectAttributes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ObjectAttributesQueryResult = NonNullable<Awaited<ReturnType<typeof objectAttributes>>>
export type ObjectAttributesQueryError = HTTPValidationError


export function useObjectAttributes<TData = Awaited<ReturnType<typeof objectAttributes>>, TError = HTTPValidationError>(
 params: undefined |  ObjectAttributesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof objectAttributes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof objectAttributes>>,
          TError,
          Awaited<ReturnType<typeof objectAttributes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useObjectAttributes<TData = Awaited<ReturnType<typeof objectAttributes>>, TError = HTTPValidationError>(
 params?: ObjectAttributesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof objectAttributes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof objectAttributes>>,
          TError,
          Awaited<ReturnType<typeof objectAttributes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useObjectAttributes<TData = Awaited<ReturnType<typeof objectAttributes>>, TError = HTTPValidationError>(
 params?: ObjectAttributesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof objectAttributes>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Object Attributes
 */

export function useObjectAttributes<TData = Awaited<ReturnType<typeof objectAttributes>>, TError = HTTPValidationError>(
 params?: ObjectAttributesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof objectAttributes>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getObjectAttributesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get Event Attributes
 */
export const getEventAttributesUrl = (params?: EventAttributesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:8000/info/events/attributes?${stringifiedParams}` : `http://localhost:8000/info/events/attributes`
}

export const eventAttributes = async (params?: EventAttributesParams, options?: RequestInit): Promise<EventAttributes200> => {
  
  return customFetch<EventAttributes200>(getEventAttributesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getEventAttributesQueryKey = (params?: EventAttributesParams,) => {
    return [`http://localhost:8000/info/events/attributes`, ...(params ? [params]: [])] as const;
    }

    
export const getEventAttributesQueryOptions = <TData = Awaited<ReturnType<typeof eventAttributes>>, TError = HTTPValidationError>(params?: EventAttributesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventAttributes>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEventAttributesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof eventAttributes>>> = ({ signal }) => eventAttributes(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 300000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof eventAttributes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EventAttributesQueryResult = NonNullable<Awaited<ReturnType<typeof eventAttributes>>>
export type EventAttributesQueryError = HTTPValidationError


export function useEventAttributes<TData = Awaited<ReturnType<typeof eventAttributes>>, TError = HTTPValidationError>(
 params: undefined |  EventAttributesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventAttributes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventAttributes>>,
          TError,
          Awaited<ReturnType<typeof eventAttributes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEventAttributes<TData = Awaited<ReturnType<typeof eventAttributes>>, TError = HTTPValidationError>(
 params?: EventAttributesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventAttributes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventAttributes>>,
          TError,
          Awaited<ReturnType<typeof eventAttributes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEventAttributes<TData = Awaited<ReturnType<typeof eventAttributes>>, TError = HTTPValidationError>(
 params?: EventAttributesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventAttributes>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Event Attributes
 */

export function useEventAttributes<TData = Awaited<ReturnType<typeof eventAttributes>>, TError = HTTPValidationError>(
 params?: EventAttributesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventAttributes>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEventAttributesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get Event Counts
 */
export const getEventCountsUrl = (params?: EventCountsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:8000/info/events/counts?${stringifiedParams}` : `http://localhost:8000/info/events/counts`
}

export const eventCounts = async (params?: EventCountsParams, options?: RequestInit): Promise<EventCounts200> => {
  
  return customFetch<EventCounts200>(getEventCountsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getEventCountsQueryKey = (params?: EventCountsParams,) => {
    return [`http://localhost:8000/info/events/counts`, ...(params ? [params]: [])] as const;
    }

    
export const getEventCountsQueryOptions = <TData = Awaited<ReturnType<typeof eventCounts>>, TError = HTTPValidationError>(params?: EventCountsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventCounts>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEventCountsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof eventCounts>>> = ({ signal }) => eventCounts(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 300000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof eventCounts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EventCountsQueryResult = NonNullable<Awaited<ReturnType<typeof eventCounts>>>
export type EventCountsQueryError = HTTPValidationError


export function useEventCounts<TData = Awaited<ReturnType<typeof eventCounts>>, TError = HTTPValidationError>(
 params: undefined |  EventCountsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventCounts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventCounts>>,
          TError,
          Awaited<ReturnType<typeof eventCounts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEventCounts<TData = Awaited<ReturnType<typeof eventCounts>>, TError = HTTPValidationError>(
 params?: EventCountsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventCounts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventCounts>>,
          TError,
          Awaited<ReturnType<typeof eventCounts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEventCounts<TData = Awaited<ReturnType<typeof eventCounts>>, TError = HTTPValidationError>(
 params?: EventCountsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventCounts>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Event Counts
 */

export function useEventCounts<TData = Awaited<ReturnType<typeof eventCounts>>, TError = HTTPValidationError>(
 params?: EventCountsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventCounts>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEventCountsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get Time Info
 */
export const getTimeInfoUrl = (params?: TimeInfoParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:8000/info/events/time?${stringifiedParams}` : `http://localhost:8000/info/events/time`
}

export const timeInfo = async (params?: TimeInfoParams, options?: RequestInit): Promise<EntityTimeInfo> => {
  
  return customFetch<EntityTimeInfo>(getTimeInfoUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getTimeInfoQueryKey = (params?: TimeInfoParams,) => {
    return [`http://localhost:8000/info/events/time`, ...(params ? [params]: [])] as const;
    }

    
export const getTimeInfoQueryOptions = <TData = Awaited<ReturnType<typeof timeInfo>>, TError = HTTPValidationError>(params?: TimeInfoParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timeInfo>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimeInfoQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timeInfo>>> = ({ signal }) => timeInfo(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 300000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timeInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TimeInfoQueryResult = NonNullable<Awaited<ReturnType<typeof timeInfo>>>
export type TimeInfoQueryError = HTTPValidationError


export function useTimeInfo<TData = Awaited<ReturnType<typeof timeInfo>>, TError = HTTPValidationError>(
 params: undefined |  TimeInfoParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof timeInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof timeInfo>>,
          TError,
          Awaited<ReturnType<typeof timeInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTimeInfo<TData = Awaited<ReturnType<typeof timeInfo>>, TError = HTTPValidationError>(
 params?: TimeInfoParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timeInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof timeInfo>>,
          TError,
          Awaited<ReturnType<typeof timeInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTimeInfo<TData = Awaited<ReturnType<typeof timeInfo>>, TError = HTTPValidationError>(
 params?: TimeInfoParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timeInfo>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Time Info
 */

export function useTimeInfo<TData = Awaited<ReturnType<typeof timeInfo>>, TError = HTTPValidationError>(
 params?: TimeInfoParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof timeInfo>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTimeInfoQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get Object Counts
 */
export const getObjectCountUrl = (params?: ObjectCountParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:8000/info/objects/counts?${stringifiedParams}` : `http://localhost:8000/info/objects/counts`
}

export const objectCount = async (params?: ObjectCountParams, options?: RequestInit): Promise<ObjectCount200> => {
  
  return customFetch<ObjectCount200>(getObjectCountUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getObjectCountQueryKey = (params?: ObjectCountParams,) => {
    return [`http://localhost:8000/info/objects/counts`, ...(params ? [params]: [])] as const;
    }

    
export const getObjectCountQueryOptions = <TData = Awaited<ReturnType<typeof objectCount>>, TError = HTTPValidationError>(params?: ObjectCountParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof objectCount>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getObjectCountQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof objectCount>>> = ({ signal }) => objectCount(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 300000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof objectCount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ObjectCountQueryResult = NonNullable<Awaited<ReturnType<typeof objectCount>>>
export type ObjectCountQueryError = HTTPValidationError


export function useObjectCount<TData = Awaited<ReturnType<typeof objectCount>>, TError = HTTPValidationError>(
 params: undefined |  ObjectCountParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof objectCount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof objectCount>>,
          TError,
          Awaited<ReturnType<typeof objectCount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useObjectCount<TData = Awaited<ReturnType<typeof objectCount>>, TError = HTTPValidationError>(
 params?: ObjectCountParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof objectCount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof objectCount>>,
          TError,
          Awaited<ReturnType<typeof objectCount>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useObjectCount<TData = Awaited<ReturnType<typeof objectCount>>, TError = HTTPValidationError>(
 params?: ObjectCountParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof objectCount>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Object Counts
 */

export function useObjectCount<TData = Awaited<ReturnType<typeof objectCount>>, TError = HTTPValidationError>(
 params?: ObjectCountParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof objectCount>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getObjectCountQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get E2O
 */
export const getE2oUrl = (params?: E2oParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:8000/info/relations/e2o?${stringifiedParams}` : `http://localhost:8000/info/relations/e2o`
}

export const e2o = async (params?: E2oParams, options?: RequestInit): Promise<RelationCountSummary[]> => {
  
  return customFetch<RelationCountSummary[]>(getE2oUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getE2oQueryKey = (params?: E2oParams,) => {
    return [`http://localhost:8000/info/relations/e2o`, ...(params ? [params]: [])] as const;
    }

    
export const getE2oQueryOptions = <TData = Awaited<ReturnType<typeof e2o>>, TError = HTTPValidationError>(params?: E2oParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof e2o>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getE2oQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof e2o>>> = ({ signal }) => e2o(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 300000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof e2o>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type E2oQueryResult = NonNullable<Awaited<ReturnType<typeof e2o>>>
export type E2oQueryError = HTTPValidationError


export function useE2o<TData = Awaited<ReturnType<typeof e2o>>, TError = HTTPValidationError>(
 params: undefined |  E2oParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof e2o>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof e2o>>,
          TError,
          Awaited<ReturnType<typeof e2o>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useE2o<TData = Awaited<ReturnType<typeof e2o>>, TError = HTTPValidationError>(
 params?: E2oParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof e2o>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof e2o>>,
          TError,
          Awaited<ReturnType<typeof e2o>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useE2o<TData = Awaited<ReturnType<typeof e2o>>, TError = HTTPValidationError>(
 params?: E2oParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof e2o>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get E2O
 */

export function useE2o<TData = Awaited<ReturnType<typeof e2o>>, TError = HTTPValidationError>(
 params?: E2oParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof e2o>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getE2oQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get Object Relations
 */
export const getO2oUrl = (params?: O2oParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:8000/info/relations/o2o?${stringifiedParams}` : `http://localhost:8000/info/relations/o2o`
}

export const o2o = async (params?: O2oParams, options?: RequestInit): Promise<RelationCountSummary[]> => {
  
  return customFetch<RelationCountSummary[]>(getO2oUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getO2oQueryKey = (params?: O2oParams,) => {
    return [`http://localhost:8000/info/relations/o2o`, ...(params ? [params]: [])] as const;
    }

    
export const getO2oQueryOptions = <TData = Awaited<ReturnType<typeof o2o>>, TError = HTTPValidationError>(params?: O2oParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof o2o>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getO2oQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof o2o>>> = ({ signal }) => o2o(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 300000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof o2o>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type O2oQueryResult = NonNullable<Awaited<ReturnType<typeof o2o>>>
export type O2oQueryError = HTTPValidationError


export function useO2o<TData = Awaited<ReturnType<typeof o2o>>, TError = HTTPValidationError>(
 params: undefined |  O2oParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof o2o>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof o2o>>,
          TError,
          Awaited<ReturnType<typeof o2o>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useO2o<TData = Awaited<ReturnType<typeof o2o>>, TError = HTTPValidationError>(
 params?: O2oParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof o2o>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof o2o>>,
          TError,
          Awaited<ReturnType<typeof o2o>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useO2o<TData = Awaited<ReturnType<typeof o2o>>, TError = HTTPValidationError>(
 params?: O2oParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof o2o>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Object Relations
 */

export function useO2o<TData = Awaited<ReturnType<typeof o2o>>, TError = HTTPValidationError>(
 params?: O2oParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof o2o>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getO2oQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



