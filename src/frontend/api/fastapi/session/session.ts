/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * OCEAn
 * OpenAPI spec version: 0.9.12
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  DeleteOcelParams,
  GetOcelResponse,
  GetTaskParams,
  HTTPValidationError,
  RenameOcelParams,
  SetCurrentOcelParams,
  TaskSummary
} from '../../fastapi-schemas';

import { customFetch } from '../../fetcher';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary Deletes the Session
 */
export const getLogoutUrl = () => {


  

  return `http://localhost:8000/session/logout`
}

export const logout = async ( options?: RequestInit): Promise<unknown> => {
  
  return customFetch<unknown>(getLogoutUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getLogoutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext> => {

const mutationKey = ['logout'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
          

          return  logout(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>
    
    export type LogoutMutationError = unknown

    /**
 * @summary Deletes the Session
 */
export const useLogout = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof logout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getLogoutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Get Uploaded OCELs
 */
export const getGetOcelsUrl = () => {


  

  return `http://localhost:8000/session/ocels`
}

export const getOcels = async ( options?: RequestInit): Promise<GetOcelResponse> => {
  
  return customFetch<GetOcelResponse>(getGetOcelsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetOcelsQueryKey = () => {
    return [`http://localhost:8000/session/ocels`] as const;
    }

    
export const getGetOcelsQueryOptions = <TData = Awaited<ReturnType<typeof getOcels>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOcels>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOcelsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOcels>>> = ({ signal }) => getOcels({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 300000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOcels>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOcelsQueryResult = NonNullable<Awaited<ReturnType<typeof getOcels>>>
export type GetOcelsQueryError = unknown


export function useGetOcels<TData = Awaited<ReturnType<typeof getOcels>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOcels>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOcels>>,
          TError,
          Awaited<ReturnType<typeof getOcels>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOcels<TData = Awaited<ReturnType<typeof getOcels>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOcels>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOcels>>,
          TError,
          Awaited<ReturnType<typeof getOcels>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOcels<TData = Awaited<ReturnType<typeof getOcels>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOcels>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Uploaded OCELs
 */

export function useGetOcels<TData = Awaited<ReturnType<typeof getOcels>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOcels>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOcelsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get Uploaded OCELs
 */
export const getSetCurrentOcelUrl = (params: SetCurrentOcelParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:8000/session/ocel?${stringifiedParams}` : `http://localhost:8000/session/ocel`
}

export const setCurrentOcel = async (params: SetCurrentOcelParams, options?: RequestInit): Promise<unknown> => {
  
  return customFetch<unknown>(getSetCurrentOcelUrl(params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getSetCurrentOcelMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setCurrentOcel>>, TError,{params: SetCurrentOcelParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof setCurrentOcel>>, TError,{params: SetCurrentOcelParams}, TContext> => {

const mutationKey = ['setCurrentOcel'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof setCurrentOcel>>, {params: SetCurrentOcelParams}> = (props) => {
          const {params} = props ?? {};

          return  setCurrentOcel(params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SetCurrentOcelMutationResult = NonNullable<Awaited<ReturnType<typeof setCurrentOcel>>>
    
    export type SetCurrentOcelMutationError = HTTPValidationError

    /**
 * @summary Get Uploaded OCELs
 */
export const useSetCurrentOcel = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setCurrentOcel>>, TError,{params: SetCurrentOcelParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof setCurrentOcel>>,
        TError,
        {params: SetCurrentOcelParams},
        TContext
      > => {

      const mutationOptions = getSetCurrentOcelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Deletes the ocel with the id
 */
export const getDeleteOcelUrl = (params: DeleteOcelParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:8000/session/ocel/delete?${stringifiedParams}` : `http://localhost:8000/session/ocel/delete`
}

export const deleteOcel = async (params: DeleteOcelParams, options?: RequestInit): Promise<unknown> => {
  
  return customFetch<unknown>(getDeleteOcelUrl(params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getDeleteOcelMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteOcel>>, TError,{params: DeleteOcelParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteOcel>>, TError,{params: DeleteOcelParams}, TContext> => {

const mutationKey = ['deleteOcel'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteOcel>>, {params: DeleteOcelParams}> = (props) => {
          const {params} = props ?? {};

          return  deleteOcel(params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteOcelMutationResult = NonNullable<Awaited<ReturnType<typeof deleteOcel>>>
    
    export type DeleteOcelMutationError = HTTPValidationError

    /**
 * @summary Deletes the ocel with the id
 */
export const useDeleteOcel = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteOcel>>, TError,{params: DeleteOcelParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteOcel>>,
        TError,
        {params: DeleteOcelParams},
        TContext
      > => {

      const mutationOptions = getDeleteOcelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Renames the ocel with the id
 */
export const getRenameOcelUrl = (params: RenameOcelParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:8000/session/ocel/rename?${stringifiedParams}` : `http://localhost:8000/session/ocel/rename`
}

export const renameOcel = async (params: RenameOcelParams, options?: RequestInit): Promise<unknown> => {
  
  return customFetch<unknown>(getRenameOcelUrl(params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getRenameOcelMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof renameOcel>>, TError,{params: RenameOcelParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof renameOcel>>, TError,{params: RenameOcelParams}, TContext> => {

const mutationKey = ['renameOcel'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof renameOcel>>, {params: RenameOcelParams}> = (props) => {
          const {params} = props ?? {};

          return  renameOcel(params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RenameOcelMutationResult = NonNullable<Awaited<ReturnType<typeof renameOcel>>>
    
    export type RenameOcelMutationError = HTTPValidationError

    /**
 * @summary Renames the ocel with the id
 */
export const useRenameOcel = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof renameOcel>>, TError,{params: RenameOcelParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof renameOcel>>,
        TError,
        {params: RenameOcelParams},
        TContext
      > => {

      const mutationOptions = getRenameOcelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary returns all tasks of a session
 */
export const getGetTasksUrl = () => {


  

  return `http://localhost:8000/tasks/`
}

export const getTasks = async ( options?: RequestInit): Promise<TaskSummary[]> => {
  
  return customFetch<TaskSummary[]>(getGetTasksUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetTasksQueryKey = () => {
    return [`http://localhost:8000/tasks/`] as const;
    }

    
export const getGetTasksQueryOptions = <TData = Awaited<ReturnType<typeof getTasks>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTasks>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTasksQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTasks>>> = ({ signal }) => getTasks({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 300000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTasks>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTasksQueryResult = NonNullable<Awaited<ReturnType<typeof getTasks>>>
export type GetTasksQueryError = unknown


export function useGetTasks<TData = Awaited<ReturnType<typeof getTasks>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTasks>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTasks>>,
          TError,
          Awaited<ReturnType<typeof getTasks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTasks<TData = Awaited<ReturnType<typeof getTasks>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTasks>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTasks>>,
          TError,
          Awaited<ReturnType<typeof getTasks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTasks<TData = Awaited<ReturnType<typeof getTasks>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTasks>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary returns all tasks of a session
 */

export function useGetTasks<TData = Awaited<ReturnType<typeof getTasks>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTasks>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTasksQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary returns the task of a given taskId
 */
export const getGetTaskUrl = (params: GetTaskParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:8000/tasks/task?${stringifiedParams}` : `http://localhost:8000/tasks/task`
}

export const getTask = async (params: GetTaskParams, options?: RequestInit): Promise<TaskSummary> => {
  
  return customFetch<TaskSummary>(getGetTaskUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetTaskQueryKey = (params: GetTaskParams,) => {
    return [`http://localhost:8000/tasks/task`, ...(params ? [params]: [])] as const;
    }

    
export const getGetTaskQueryOptions = <TData = Awaited<ReturnType<typeof getTask>>, TError = HTTPValidationError>(params: GetTaskParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTaskQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTask>>> = ({ signal }) => getTask(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 300000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTaskQueryResult = NonNullable<Awaited<ReturnType<typeof getTask>>>
export type GetTaskQueryError = HTTPValidationError


export function useGetTask<TData = Awaited<ReturnType<typeof getTask>>, TError = HTTPValidationError>(
 params: GetTaskParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTask>>,
          TError,
          Awaited<ReturnType<typeof getTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTask<TData = Awaited<ReturnType<typeof getTask>>, TError = HTTPValidationError>(
 params: GetTaskParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTask>>,
          TError,
          Awaited<ReturnType<typeof getTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTask<TData = Awaited<ReturnType<typeof getTask>>, TError = HTTPValidationError>(
 params: GetTaskParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary returns the task of a given taskId
 */

export function useGetTask<TData = Awaited<ReturnType<typeof getTask>>, TError = HTTPValidationError>(
 params: GetTaskParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTaskQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



