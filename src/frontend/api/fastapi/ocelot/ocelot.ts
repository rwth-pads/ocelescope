/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * OCEAn
 * OpenAPI spec version: 0.9.12
 */
import {
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  EventInfoParams,
  HTTPValidationError,
  ObjectInfoParams,
  PaginatedEventsParams,
  PaginatedObjectsParams,
  PaginatedResponse
} from '../../fastapi-schemas';

import { customFetch } from '../../fetcher';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary Get Events
 */
export const getPaginatedEventsUrl = (params: PaginatedEventsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:8000/ocelot/events?${stringifiedParams}` : `http://localhost:8000/ocelot/events`
}

export const paginatedEvents = async (params: PaginatedEventsParams, options?: RequestInit): Promise<PaginatedResponse> => {
  
  return customFetch<PaginatedResponse>(getPaginatedEventsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getPaginatedEventsQueryKey = (params: PaginatedEventsParams,) => {
    return [`http://localhost:8000/ocelot/events`, ...(params ? [params]: [])] as const;
    }

    
export const getPaginatedEventsQueryOptions = <TData = Awaited<ReturnType<typeof paginatedEvents>>, TError = HTTPValidationError>(params: PaginatedEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paginatedEvents>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaginatedEventsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paginatedEvents>>> = ({ signal }) => paginatedEvents(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 300000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paginatedEvents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PaginatedEventsQueryResult = NonNullable<Awaited<ReturnType<typeof paginatedEvents>>>
export type PaginatedEventsQueryError = HTTPValidationError


export function usePaginatedEvents<TData = Awaited<ReturnType<typeof paginatedEvents>>, TError = HTTPValidationError>(
 params: PaginatedEventsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paginatedEvents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paginatedEvents>>,
          TError,
          Awaited<ReturnType<typeof paginatedEvents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaginatedEvents<TData = Awaited<ReturnType<typeof paginatedEvents>>, TError = HTTPValidationError>(
 params: PaginatedEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paginatedEvents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paginatedEvents>>,
          TError,
          Awaited<ReturnType<typeof paginatedEvents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaginatedEvents<TData = Awaited<ReturnType<typeof paginatedEvents>>, TError = HTTPValidationError>(
 params: PaginatedEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paginatedEvents>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Events
 */

export function usePaginatedEvents<TData = Awaited<ReturnType<typeof paginatedEvents>>, TError = HTTPValidationError>(
 params: PaginatedEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paginatedEvents>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPaginatedEventsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get Objects
 */
export const getPaginatedObjectsUrl = (params: PaginatedObjectsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:8000/ocelot/objects?${stringifiedParams}` : `http://localhost:8000/ocelot/objects`
}

export const paginatedObjects = async (params: PaginatedObjectsParams, options?: RequestInit): Promise<PaginatedResponse> => {
  
  return customFetch<PaginatedResponse>(getPaginatedObjectsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getPaginatedObjectsQueryKey = (params: PaginatedObjectsParams,) => {
    return [`http://localhost:8000/ocelot/objects`, ...(params ? [params]: [])] as const;
    }

    
export const getPaginatedObjectsQueryOptions = <TData = Awaited<ReturnType<typeof paginatedObjects>>, TError = HTTPValidationError>(params: PaginatedObjectsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paginatedObjects>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaginatedObjectsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paginatedObjects>>> = ({ signal }) => paginatedObjects(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 300000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paginatedObjects>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PaginatedObjectsQueryResult = NonNullable<Awaited<ReturnType<typeof paginatedObjects>>>
export type PaginatedObjectsQueryError = HTTPValidationError


export function usePaginatedObjects<TData = Awaited<ReturnType<typeof paginatedObjects>>, TError = HTTPValidationError>(
 params: PaginatedObjectsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paginatedObjects>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paginatedObjects>>,
          TError,
          Awaited<ReturnType<typeof paginatedObjects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaginatedObjects<TData = Awaited<ReturnType<typeof paginatedObjects>>, TError = HTTPValidationError>(
 params: PaginatedObjectsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paginatedObjects>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paginatedObjects>>,
          TError,
          Awaited<ReturnType<typeof paginatedObjects>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaginatedObjects<TData = Awaited<ReturnType<typeof paginatedObjects>>, TError = HTTPValidationError>(
 params: PaginatedObjectsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paginatedObjects>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Objects
 */

export function usePaginatedObjects<TData = Awaited<ReturnType<typeof paginatedObjects>>, TError = HTTPValidationError>(
 params: PaginatedObjectsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paginatedObjects>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPaginatedObjectsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get Objects Info
 */
export const getObjectInfoUrl = (params?: ObjectInfoParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:8000/ocelot/objectInfo?${stringifiedParams}` : `http://localhost:8000/ocelot/objectInfo`
}

export const objectInfo = async (params?: ObjectInfoParams, options?: RequestInit): Promise<string[]> => {
  
  return customFetch<string[]>(getObjectInfoUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getObjectInfoQueryKey = (params?: ObjectInfoParams,) => {
    return [`http://localhost:8000/ocelot/objectInfo`, ...(params ? [params]: [])] as const;
    }

    
export const getObjectInfoQueryOptions = <TData = Awaited<ReturnType<typeof objectInfo>>, TError = HTTPValidationError>(params?: ObjectInfoParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof objectInfo>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getObjectInfoQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof objectInfo>>> = ({ signal }) => objectInfo(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 300000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof objectInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ObjectInfoQueryResult = NonNullable<Awaited<ReturnType<typeof objectInfo>>>
export type ObjectInfoQueryError = HTTPValidationError


export function useObjectInfo<TData = Awaited<ReturnType<typeof objectInfo>>, TError = HTTPValidationError>(
 params: undefined |  ObjectInfoParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof objectInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof objectInfo>>,
          TError,
          Awaited<ReturnType<typeof objectInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useObjectInfo<TData = Awaited<ReturnType<typeof objectInfo>>, TError = HTTPValidationError>(
 params?: ObjectInfoParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof objectInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof objectInfo>>,
          TError,
          Awaited<ReturnType<typeof objectInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useObjectInfo<TData = Awaited<ReturnType<typeof objectInfo>>, TError = HTTPValidationError>(
 params?: ObjectInfoParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof objectInfo>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Objects Info
 */

export function useObjectInfo<TData = Awaited<ReturnType<typeof objectInfo>>, TError = HTTPValidationError>(
 params?: ObjectInfoParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof objectInfo>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getObjectInfoQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get Event Info
 */
export const getEventInfoUrl = (params?: EventInfoParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:8000/ocelot/eventInfo?${stringifiedParams}` : `http://localhost:8000/ocelot/eventInfo`
}

export const eventInfo = async (params?: EventInfoParams, options?: RequestInit): Promise<string[]> => {
  
  return customFetch<string[]>(getEventInfoUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getEventInfoQueryKey = (params?: EventInfoParams,) => {
    return [`http://localhost:8000/ocelot/eventInfo`, ...(params ? [params]: [])] as const;
    }

    
export const getEventInfoQueryOptions = <TData = Awaited<ReturnType<typeof eventInfo>>, TError = HTTPValidationError>(params?: EventInfoParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventInfo>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEventInfoQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof eventInfo>>> = ({ signal }) => eventInfo(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 300000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof eventInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EventInfoQueryResult = NonNullable<Awaited<ReturnType<typeof eventInfo>>>
export type EventInfoQueryError = HTTPValidationError


export function useEventInfo<TData = Awaited<ReturnType<typeof eventInfo>>, TError = HTTPValidationError>(
 params: undefined |  EventInfoParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventInfo>>,
          TError,
          Awaited<ReturnType<typeof eventInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEventInfo<TData = Awaited<ReturnType<typeof eventInfo>>, TError = HTTPValidationError>(
 params?: EventInfoParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventInfo>>,
          TError,
          Awaited<ReturnType<typeof eventInfo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEventInfo<TData = Awaited<ReturnType<typeof eventInfo>>, TError = HTTPValidationError>(
 params?: EventInfoParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventInfo>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Event Info
 */

export function useEventInfo<TData = Awaited<ReturnType<typeof eventInfo>>, TError = HTTPValidationError>(
 params?: EventInfoParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventInfo>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEventInfoQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



